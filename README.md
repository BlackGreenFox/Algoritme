# Algoritme


## Тема 1.1 | Швидкість Відпрацювання Алгориму

Швидкість відпрацювання алгоритму визначається його часовою складністю, яка в аналізі алгоритмів виражається у величині О-велике (O-notation). Ця нотація допомагає оцінити, як змінюється час виконання алгоритму зі зростанням розміру вхідних даних (n). Основна ідея полягає в тому, щоб визначити, як змінюється кількість операцій алгоритму при збільшенні об'єму вхідних даних, і виразити цю залежність у вигляді математичного виразу.

1. O(1) - константний час:
Алгоритм має постійний час виконання незалежно від розміру вхідних даних.

Приклад: Доступ до елементу за індексом в масиві.

2. O(log(n)) - логарифмічний час:
Час виконання зростає логарифмічно зі збільшенням розміру вхідних даних.

Приклад: Пошук елементу в відсортованому масиві за допомогою бінарного пошуку.

3. O(n) - лінійний час:
Час виконання зростає лінійно зі збільшенням розміру вхідних даних.

Приклад: Пошук максимального елементу в несортованому масиві.

4. O(n log(n)) - лінійнийіт логарифмічний час:
Час виконання зростає немного швидше, ніж лінійно, але повільніше, ніж лінійно-квазіадитивний час.

Приклад: Швидке сортування (QuickSort).

5. O(n^2) - квадратичний час:
Час виконання зростає квадратично зі збільшенням розміру вхідних даних.

Приклад: Сортування бульбашкою (Bubble Sort).

6. O(2^n) - експоненційний час:
Час виконання зростає експоненційно зі збільшенням розміру вхідних даних.

Приклад: Розв'язання задачі комівояжера за допомогою повного перебору.


![О велике в дії](https://github.com/BlackGreenFox/Manual_Algoritme/blob/main/Images/O_big_diff.png?raw=true)


> :pushpin:
> Нижче знаходяться вправи для закріплення матеріалу
> 
<details>
<summary> Вправи для закріплення </summary>

### Наведіть час виконання «О-велике» для кожного з наступних сценаріїв.

- [ ] Відоме прізвище, потрібно знайти номер у телефонній книзі.
- [ ] Відомий номер, потрібно знайти прізвище телефонної книги. (Підказка: вам доведеться провести пошук по всій книзі!)
- [ ] Потрібно прочитати телефони всіх людей телефонної книги.
- [ ] Потрібно прочитати телефони всіх людей, прізвища яких починаються з літери "А". (Питання з каверзою!)

</details>

> :books:
> Нижче знаходяться додаткові пам'ятки

<details>
<summary> Додатково </summary>

### 

- [x] Бінарний пошук працює набагато швидше, ніж простий.
- [x] Час виконання O(log п) швидше О(п), а зі збільшенням розміру списку, в якому шукається значення, воно стає набагато швидшим.
- [x] Швидкість алгоритмів не вимірюється за секунди.
- [x] Час виконання алгоритму описується зростанням кількості операцій.
- [x] Час виконання алгоритмів виражається як «О-велике.

</details>

## Тема 1.2 | Типи Алгоритмів
### Сортування:
Алгоритми сортування використовуються для організації елементів у певному порядку. Розрізняють такі типи сортування:

Лінійні: Основна характеристика полягає в тому, що кількість порівнянь та перестановок пропорційна кількості елементів.
Приклади: Бульбашкове сортування, Вставне сортування.
Нелінійні: Кількість порівнянь та перестановок може змінюватися в залежності від вхідних даних.
Приклади: Швидке сортування (QuickSort), Злиття (Merge Sort).

### Пошук:
Алгоритми пошуку використовуються для знаходження конкретного елементу у великій колекції даних.

Лінійний пошук: Проходження через елементи послідовно з порівнянням.
Бінарний пошук: Використовується тільки для відсортованих даних, шукає елемент шляхом ділення простору пошуку на піві.
Графові:
Графові алгоритми використовуються для роботи з графами (наборами вузлів, пов'язаних ребрами).

Алгоритми пошуку в ширину (BFS) та в глибину (DFS): Використовуються для обходу графів та знаходження шляхів між вузлами.
Алгоритм Дейкстри: Використовується для знаходження найкоротших шляхів у вагованих графах.
Алгоритм Прима та Крускала: Використовуються для знаходження мінімального остовного дерева.
### Жадібні алгоритми:
Жадібні алгоритми роблять локально оптимальні вибори на кожному кроці в надії, що це призведе до глобально оптимального результату.
Приклади: Алгоритм Дейкстри, Жадібний алгоритм для задачі охоплення множини.

### Динамічне програмування:
Алгоритми динамічного програмування розбивають великі проблеми на менші підзадачі і зберігають результати підзадач для ефективного використання.
Приклади: Задача рюкзака, Задача про найкоротший шлях, Редакційна відстань.

### Математичні алгоритми:
Ці алгоритми використовують математичні методи для розв'язання конкретних завдань.

Алгоритм Евкліда: Використовується для знаходження найбільшого спільного дільника.
Алгоритм RSA: Використовується для шифрування та дешифрування повідомлень.

## Тема 1.3 | Типи Структур Даних
### Масив (Array): 
Масив - це послідовність елементів одного типу, зібраних під одним ім'ям. Елементи доступні за індексами.

### Зв'язний список (Linked List): 
Зв'язний список - це структура, де кожен елемент (вузол) містить дані та вказівник на наступний елемент у послідовності.

### Стек (Stack): 
Стек - це структура даних, де доступ до даних здійснюється за принципом "останній прийшов, перший вийшов" (LIFO). Елементи можуть бути додані або видалені лише з вершини стеку.

### Черга (Queue): 
Черга - це структура даних, де доступ до даних здійснюється за принципом "перший прийшов, перший вийшов" (FIFO). Елементи додаються в кінець черги і видаляються з початку.

### Дерево (Tree): 
Дерево - це ієрархічна структура даних, де кожен елемент називається вузол. Верхній вузол називається коренем, і кожен вузол може мати декілька дочірніх вузлів, які в свою чергу можуть мати свої дочірні вузли.

### Граф (Graph): 
Граф - це набір вершин, пов'язаних ребрами. Вершини можуть мати різні типи зв'язків: напрямлені, ненапрямлені, ваговані тощо.

### Хеш-таблиця (Hash Table): 
Хеш-таблиця - це структура, яка забезпечує швидкий доступ до даних за допомогою хеш-функції, яка перетворює ключ у вказівник на місце збереження даних.

### Посилання (Pointers): 
Хоча це не структура даних у суворому сенсі, покажчики (посилання) в програмуванні грають важливу роль, дозволяючи створювати складні структури даних, які взаємодіють між собою.

### Бінарний пошуковий дерево (Binary Search Tree): 
Це вид дерева, де кожен вузол має не більше двох дочірніх вузлів, і вузли впорядковані так, що значення в лівому піддереві менше або рівне значенню батька, а в правому піддереві - більше.

### Гіперграф (Hypergraph): 
Розширення ідеї графа, де ребра можуть з'єднувати більше двох вершин.

## Тема 2.1 | Масиви і Звя'зні списки
Масив - це структура даних у програмуванні, яка дозволяє зберігати та упорядковувати набір однотипних елементів під однією змінною. Основна ідея полягає у тому, щоб мати зручний спосіб доступу до кожного елемента масиву за допомогою індексу, який вказує на його позицію в масиві. У більшості мов програмування індекси масивів починаються з нуля. Це означає, що перший елемент масиву буде мати індекс 0, другий - індекс 1 і так далі. Масиви можуть бути одновимірними (містять одну лінію елементів) та багатовимірними (матриці, куби та інші форми).

Пов'язаний список - це структура даних у програмуванні, яка дозволяє зберігати та упорядковувати набір елементів, кожен з яких містить саму інформацію та вказівку на наступний елемент у списку. Кожен елемент такого списку називається "вузол". Основна відмінність між масивом та пов'язаним списком полягає у способі зберігання та доступу до даних. У масивах ми маємо прямий доступ до елементів за допомогою їх індексів, а в пов'язаних списках доступ до елементів здійснюється за допомогою послідовної навігації від одного вузла до наступного.

Кожен вузол пов'язаного списку містить два основних поля:

1. Дані: Інформація, яку ми зберігаємо у вузлі.
2. Вказівник на наступний вузол: Це посилання на наступний вузол у списку.

Така структура дозволяє створювати зв'язок між вузлами, утворюючи послідовність елементів. Останній вузол вказує на null або спеціальне значення, що позначає кінець списку.

Дії над ціми структурами даних

![Складність дій](https://github.com/BlackGreenFox/Manual_Algoritme/blob/main/Images/Array_diff.jpg?raw=true)

> :pushpin:
> Нижче знаходяться вправа
> 
<details>
<summary> Вправа для закріплення </summary>

### Сортування вибором

- [ ] А тепер об'єднаємо все, що ви дізналися, у другому алгоритмі: сортуванні вибором. Щоб освоїти цей алгоритм, ви повинні розуміти, як
працюють масиви та списки та «О-велике~.
Припустимо, у вас на комп'ютері записана музика і для кожного виконавця зберігається лічильник відтворений. Ви хочете відсортувати список за спаданням лічильника відтворень,
щоб найулюбленіші виконавці стояли на перших місцях. Одне з можливих рішень - пройти за списком та знайти виконавця із найбільшою кількістю відтворень. Цей виконавець додається до нового списку.
![Скріншот задачі](https://github.com/BlackGreenFox/Manual_Algoritme/blob/main/Images/Base_sort.jpg?raw=true)
</details>

## Тема 3.1 | Рекурсія
Рекурсія - це концепція в програмуванні та математиці, яка вказує на можливість функції (або процедури) викликати саму себе в свому власному визначенні. Ця ідея може спричиняти створення потужних та ефективних рішень для завдань, які мають структуру, пов'язану з більш простими або подібними завданнями.
Рекурсія базується на двох ключових аспектах:
1. Визначення завдання через самого себе: В рекурсивних функціях частина завдання розбивається на більш прості частини того ж самого завдання. Ці більш прості частини потім обробляються шляхом виклику тієї ж функції.
2. Базовий випадок: Для того щоб уникнути безкінечного рекурсивного виклику, необхідно визначити базовий випадок, коли виклик функції більше не відбувається, і результат може бути одразу повернути.

> :books:
> Нижче знаходяться додаткові пам'ятки

<details>
<summary> Додатково </summary>

### 

Часова складність рекурсивних алгоритмів може значно варіюватися в залежності від того, як вони реалізовані та які оптимізації застосовані. Зазвичай часова складність рекурсивного алгоритму визначається кількістю рекурсивних викликів та часом, потрібним для обробки кожного виклику.

У випадку деяких рекурсивних алгоритмів, таких як обчислення факторіала чи чисел Фібоначчі, часова складність може бути досить високою. Ось кілька прикладів:

1. Обчислення факторіала: Якщо ви використовуєте просту рекурсивну функцію для обчислення факторіала числа n, часова складність буде O(n), оскільки у вас буде n рекурсивних викликів, кожен з яких обробляється за константний час.
2. Числа Фібоначчі: Рекурсивний підхід до обчислення чисел Фібоначчі також може мати часову складність O(2^n), оскільки кожен виклик функції породжує два додаткові виклики, що призводить до експоненційного зростання кількості викликів при збільшенні n.

</details>

## Тема 3.2 | Стеки

Призначення динамічної структури даних типу "стек". Способи реалізації стеку
Стек - це динамічна структура збереження даних, яка працює за принципом "останній прийшов - перший вийшов" (Last-In First-Out). У стеку додавання нових елементів та видалення існуючих елементів проводиться з одного кінця, який називається вершиною стека.

Організація даних за допомогою стека ефективна, коли потрібно реалізувати:
- обмін даними між методами застосування за допомогою параметрів;
- синтаксичний аналіз різноманітних виразів.

У програмуванні стек можна реалізовувати різними способами, наприклад:

- у вигляді статичного масиву;
- у вигляді динамічного масиву;
- у вигляді однозв'язкового списку;
- як двозв'язного списку.

Які операції можна виконувати над стеком та його елементами?
Над стеком та його елементами можна виконувати такі операції:

- додавання елемента до стек (push);
- витягування (видалення) елемента зі стека (pop);
- перегляд елемента у вершині стека без його витягування зі стека;
- перевірка, чи порожній стек;
- визначення кількості елементів у стеку;
- відображення (перегляд) всього стека.


> :pushpin:
> Способ реалізації стеку
> 
<details>
<summary> Приклад реалізації стеку </summary>
  
```c++
#include <iostream>
#include <new>
using namespace std;

// класс, реализующий стек в виде динамического массива
template <typename T>
class STACK
{
private:
  T* stack; // Динамический масив-указатель на стек
  int count; // Вершина стека - количество элементов типа T в стеке

public:
  // конструктор по умолчанию
  STACK()
  {
    stack = nullptr; // необязательно
    count = 0; // количество элементов в стеке определяется по значению count
  }

  // помістити елемент в стек
  void push(T item)
  {
    T* tmp; // временный указатель

    // блок try необходим для перехвата исключения, если память не выделится
    try {
      // указатель указывает на stack
      tmp = stack;

      // выделить память на 1 элемент больше, чем было выделено до этого
      stack = new T[count + 1];

      // увеличить количество элементов в стеке на 1
      count++;

      // скопировать данные из памяти, на которую указывает tmp в память,
      // на которую указывает stack
      for (int i = 0; i < count - 1; i++)
        stack[i] = tmp[i];

      // добавить последний элемент
      stack[count - 1] = item;

      // освободить память, выделенную перед этим для stack,
      // на эту память указывает tmp
      if (count > 1)
        delete[] tmp;
    }
    catch (bad_alloc e)
    {
      // если память не выделилась
      cout << e.what() << endl;
    }
  }

  // Вытягнуть элемент из стека
  // При вытягивании элемента из стека память не переопределяется
  T pop()
  {
    if (count == 0)
      return 0; // стек пуст
    count--;
    return stack[count];
  }

  // Просмотр элемента в вершине стека
  T Head()
  {
    if (count == 0)
      return 0;
    return stack[count - 1];
  }

  // конструктор копирования STACK(const STACK&) - необходим для избежания
  // недостатков побитового копирования
  STACK(const STACK& st)
  {
    try {
      // 1. Выделить новый участок памяти для массива stack
      stack = new T[st.count];

      // 2. Скопировать данные из st в текущий объект
      count = st.count;
      for (int i = 0; i < count; i++)
        stack[i] = st.stack[i];
    }
    catch (bad_alloc e)
    {
      // если память не выделилась, то вывести соответствующее сообщение
      cout << e.what() << endl;
    }
  }

  // операторная функция operator=(const STACK&) - необходима для избежания
  // недостатков побитового копирования
  STACK operator=(const STACK& st)
  {
    // Нужно скопировать из st в текущий объект
    // 1. Освободить предварительно выделенную память для текущего объекта
    if (count > 0)
    {
      count = 0;
      delete[] stack; // освободить память под предыдущий массив
    }

    // 2. Выделить новый участок памяти для массива stack
    try {
      // попытка выделить память
      stack = new T[st.count];

      // 3. Скопировать данные из st в текущий объект
      count = st.count;
      for (int i = 0; i < count; i++)
        stack[i] = st.stack[i];
    }
    catch (bad_alloc e)
    {
      // если не удалось виделить память, то вывести соответствующее сообщение
      cout << e.what() << endl;
    }

    // 4. Вернуть текущий объект
    return *this;
  }

  // Деструктор - освобождает память
  ~STACK()
  {
    if (count > 0)
      delete[] stack;
  }

  // Количество элементов в стеке
  int Count()
  {
    return count;
  }

  // Функция, которая определяет пуст ли стек
  bool IsEmpty()
  {
    return count == 0;
  }

  // Функция, выводящая стек
  void Print()
  {
    T* p; // временный указатель, двигается по элементах стека

    // 1. Установить указатель p на вершину стека
    p = stack;

    // 2. Вивід
    cout << "Stack: " << endl;
    if (count == 0)
      cout << "is empty." << endl;

    for (int i = 0; i < count; i++)
    {
      cout << "Item[" << i << "] = " << *p << endl;
      p++; // прокрутить указатель на следующий элемент
    }
    cout << endl;
  }
};

void main()
{
  // объявить стек из целых чисел
  STACK <int> st1;

  st1.Print(); // st1 = { }

  // +5
  st1.push(5); // st1 = { 5 }

  // +9
  st1.push(9); // st1 = { 5, 9 }

  // +13
  st1.push(13); // st1 = { 5, 9, 13 }

  // +7
  st1.push(7); // st1 = { 5, 9, 13, 7 }
  st1.Print();
  cout << "Count: " << st1.Count() << endl;

  // ----------------------
  STACK<int> st2;
  st2 = st1; // вызов оператора копирования
  STACK<int> st3 = st2; // вызов конструктора копирования
  // ----------------------

  // -1 item
  int t;
  t = st1.pop(); // t = 7
  cout << "Delete item: " << t << endl;
  st1.Print(); // 5, 9, 13
  cout << "Head: " << st1.Head() << endl;

  // -2 items
  st1.pop(); // st1 = { 5, 9 }
  st1.pop(); // st1 = { 5 }
  st1.Print();

  // -2 items
  st1.pop(); // st1 = { }
  st1.pop();
  st1.Print();

  if (st1.IsEmpty())
    cout << "Stack is empty." << endl;
  else
    cout << "Stack is not empty" << endl;

  cout << "Stack st2:" << endl;
  st2.Print();

  cout << "Stack st3:" << endl;
  st3.Print();

  // вызов оператора копирования в виде цепочки
  st1 = st3 = st2;
  st1.Print();
}
```
</details>

## Тема 4.1 | Стеки
